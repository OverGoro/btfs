#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <linux/limits.h>
#include <pthread.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/rfcomm.h>
#include <linux/netlink.h>

#include "btfs_types.h"

#define BUFFER_SIZE 4096
#define PROTOCOL_VERSION 1
#define NETLINK_USER 31

static int bt_socket = -1;
static int nl_socket = -1;
static uint32_t sequence = 0;
static pthread_mutex_t sequence_mutex = PTHREAD_MUTEX_INITIALIZER;

static int connect_to_server(const char *server_addr) {
    struct sockaddr_rc addr = {0};
    int sock;
    
    sock = socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
    if (sock < 0) {
        return -1;
    }
    
    addr.rc_family = AF_BLUETOOTH;
    addr.rc_channel = 1;
    str2ba(server_addr, &addr.rc_bdaddr);
    
    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        close(sock);
        return -1;
    }
    
    return sock;
}

static int send_request(int command, const void *data, size_t data_len) {
    btfs_header_t header;
    ssize_t bytes_sent;
    
    pthread_mutex_lock(&sequence_mutex);
    header.version = PROTOCOL_VERSION;
    header.command = command;
    header.sequence = sequence++;
    header.data_len = data_len;
    pthread_mutex_unlock(&sequence_mutex);
    
    bytes_sent = write(bt_socket, &header, sizeof(header));
    if (bytes_sent != sizeof(header)) {
        return -1;
    }
    
    if (data && data_len > 0) {
        bytes_sent = write(bt_socket, data, data_len);
        if (bytes_sent != (ssize_t)data_len) {
            return -1;
        }
    }
    
    return header.sequence;
}

static int receive_response(uint32_t expected_sequence, void *buffer, size_t buffer_size) {
    btfs_header_t header;
    ssize_t bytes_read;
    
    bytes_read = read(bt_socket, &header, sizeof(header));
    if (bytes_read != sizeof(header)) {
        return -1;
    }
    
    if (header.sequence != expected_sequence) {
        return -1;
    }
    
    if (header.data_len > 0) {
        if (header.data_len > buffer_size) {
            return -1;
        }
        bytes_read = read(bt_socket, buffer, header.data_len);
        if (bytes_read != (ssize_t)header.data_len) {
            return -1;
        }
    }
    
    return header.command;
}

static int handle_getattr(const char *path, struct stat *st) {
    uint32_t seq;
    int result;
    
    seq = send_request(CMD_GETATTR, path, strlen(path) + 1);
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, st, sizeof(*st));
    return result;
}

static int handle_readdir(const char *path, char *buffer, size_t buffer_size) {
    uint32_t seq;
    int result;
    
    seq = send_request(CMD_READDIR, path, strlen(path) + 1);
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, buffer, buffer_size);
    return result;
}

static int handle_read(const char *path, off_t offset, size_t size, char *buffer) {
    struct {
        off_t offset;
        size_t size;
        char path[PATH_MAX];
    } __attribute__((packed)) request;
    
    uint32_t seq;
    int result;
    
    request.offset = offset;
    request.size = size;
    strncpy(request.path, path, sizeof(request.path) - 1);
    
    seq = send_request(CMD_READ, &request, sizeof(off_t) + sizeof(size_t) + strlen(path) + 1);
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, buffer, size);
    return result;
}

static int handle_write(const char *path, off_t offset, const void *data, size_t size) {
    struct {
        off_t offset;
        size_t size;
        char data[BUFFER_SIZE - sizeof(off_t) - sizeof(size_t)];
    } __attribute__((packed)) request;
    
    uint32_t seq;
    int result;
    char response[16];
    
    if (size > sizeof(request.data)) {
        return -1;
    }
    
    request.offset = offset;
    request.size = size;
    memcpy(request.data, data, size);
    
    seq = send_request(CMD_WRITE, &request, sizeof(off_t) + sizeof(size_t) + size);
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, response, sizeof(response));
    return result;
}

static int handle_create(const char *path, mode_t mode) {
    struct {
        char path[PATH_MAX];
        mode_t mode;
    } __attribute__((packed)) request;
    
    uint32_t seq;
    int result;
    char response[16];
    
    strncpy(request.path, path, sizeof(request.path) - 1);
    request.mode = mode;
    
    seq = send_request(CMD_CREATE, &request, sizeof(request));
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, response, sizeof(response));
    return result;
}

static int handle_unlink(const char *path) {
    uint32_t seq;
    int result;
    char response[16];
    
    seq = send_request(CMD_UNLINK, path, strlen(path) + 1);
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, response, sizeof(response));
    return result;
}

static int handle_mkdir(const char *path, mode_t mode) {
    struct {
        char path[PATH_MAX];
        mode_t mode;
    } __attribute__((packed)) request;
    
    uint32_t seq;
    int result;
    char response[16];
    
    strncpy(request.path, path, sizeof(request.path) - 1);
    request.mode = mode;
    
    seq = send_request(CMD_MKDIR, &request, sizeof(request));
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, response, sizeof(response));
    return result;
}

static int handle_rename(const char *oldpath, const char *newpath) {
    struct {
        char oldpath[PATH_MAX];
        char newpath[PATH_MAX];
    } __attribute__((packed)) request;
    
    uint32_t seq;
    int result;
    char response[16];
    
    strncpy(request.oldpath, oldpath, sizeof(request.oldpath) - 1);
    strncpy(request.newpath, newpath, sizeof(request.newpath) - 1);
    
    seq = send_request(CMD_RENAME, &request, sizeof(request));
    if (seq == (uint32_t)-1) {
        return -1;
    }
    
    result = receive_response(seq, response, sizeof(response));
    return result;
}

static void send_netlink_response(int pid, uint32_t sequence, int result, const void *data, size_t data_len) {
    struct sockaddr_nl dest_addr;
    struct nlmsghdr *nlh;
    struct msghdr msg;
    struct iovec iov;
    nl_message_t *response;
    char *buf;
    int ret;
    
    buf = malloc(NLMSG_SPACE(sizeof(nl_message_t) + data_len));
    if (!buf) {
        return;
    }
    
    memset(buf, 0, NLMSG_SPACE(sizeof(nl_message_t) + data_len));
    
    nlh = (struct nlmsghdr *)buf;
    nlh->nlmsg_len = NLMSG_SPACE(sizeof(nl_message_t) + data_len);
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = 0;
    
    response = (nl_message_t *)NLMSG_DATA(nlh);
    response->command = NL_CMD_RESPONSE;
    response->sequence = sequence;
    response->result = result;
    response->data_len = data_len;
    
    if (data && data_len > 0) {
        memcpy(response->data, data, data_len);
    }
    
    memset(&dest_addr, 0, sizeof(dest_addr));
    dest_addr.nl_family = AF_NETLINK;
    dest_addr.nl_pid = pid;
    dest_addr.nl_groups = 0;
    
    iov.iov_base = (void *)buf;
    iov.iov_len = nlh->nlmsg_len;
    msg.msg_name = (void *)&dest_addr;
    msg.msg_namelen = sizeof(dest_addr);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    
    ret = sendmsg(nl_socket, &msg, 0);
    if (ret < 0) {
    }
    
    free(buf);
}

static void handle_netlink_message(struct nlmsghdr *nlh) {
    nl_message_t *msg = (nl_message_t *)NLMSG_DATA(nlh);
    int result = 0;
    void *response_data = NULL;
    size_t response_len = 0;
    
    switch (msg->command) {
        case NL_CMD_GETATTR: {
            struct btfs_getattr_request *req = (struct btfs_getattr_request *)msg->data;
            struct stat st;
            
            result = handle_getattr(req->path, &st);
            if (result == 0) {
                response_data = &st;
                response_len = sizeof(st);
            }
            break;
        }
        case NL_CMD_READDIR: {
            struct btfs_readdir_request *req = (struct btfs_readdir_request *)msg->data;
            char buffer[BUFFER_SIZE];
            
            result = handle_readdir(req->path, buffer, sizeof(buffer));
            if (result == 0) {
                response_data = buffer;
                response_len = sizeof(buffer);
            }
            break;
        }
        case NL_CMD_READ: {
            struct btfs_read_request *req = (struct btfs_read_request *)msg->data;
            char *buffer;
            
            buffer = malloc(req->size);
            if (buffer) {
                result = handle_read(req->path, req->offset, req->size, buffer);
                if (result == 0) {
                    response_data = buffer;
                    response_len = req->size;
                }
                free(buffer);
            } else {
                result = -ENOMEM;
            }
            break;
        }
        case NL_CMD_WRITE: {
            struct btfs_write_request *req = (struct btfs_write_request *)msg->data;
            
            result = handle_write(req->path, req->offset, req->data, req->size);
            break;
        }
        case NL_CMD_CREATE: {
            struct btfs_create_request *req = (struct btfs_create_request *)msg->data;
            
            result = handle_create(req->path, req->mode);
            break;
        }
        case NL_CMD_UNLINK: {
            struct btfs_unlink_request *req = (struct btfs_unlink_request *)msg->data;
            
            result = handle_unlink(req->path);
            break;
        }
        case NL_CMD_MKDIR: {
            struct btfs_mkdir_request *req = (struct btfs_mkdir_request *)msg->data;
            
            result = handle_mkdir(req->path, req->mode);
            break;
        }
        case NL_CMD_RMDIR: {
            struct btfs_unlink_request *req = (struct btfs_unlink_request *)msg->data;
            
            result = handle_unlink(req->path);
            break;
        }
        case NL_CMD_RENAME: {
            struct btfs_rename_request *req = (struct btfs_rename_request *)msg->data;
            
            result = handle_rename(req->oldpath, req->newpath);
            break;
        }
        default:
            result = -EINVAL;
            break;
    }
    
    send_netlink_response(nlh->nlmsg_pid, msg->sequence, result, response_data, response_len);
}

int main(int argc, char *argv[]) {
    struct sockaddr_nl src_addr;
    struct nlmsghdr *nlh = NULL;
    struct iovec iov;
    struct msghdr msg;
    
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <server_mac>\n", argv[0]);
        exit(1);
    }
    
    bt_socket = connect_to_server(argv[1]);
    if (bt_socket < 0) {
        fprintf(stderr, "Failed to connect to server %s\n", argv[1]);
        exit(1);
    }
    
    nl_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);
    if (nl_socket < 0) {
        perror("netlink socket");
        close(bt_socket);
        exit(1);
    }
    
    memset(&src_addr, 0, sizeof(src_addr));
    src_addr.nl_family = AF_NETLINK;
    src_addr.nl_pid = getpid();
    src_addr.nl_groups = 0;
    
    if (bind(nl_socket, (struct sockaddr*)&src_addr, sizeof(src_addr)) < 0) {
        perror("netlink bind");
        close(bt_socket);
        close(nl_socket);
        exit(1);
    }
    
    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(BUFFER_SIZE));
    if (!nlh) {
        close(bt_socket);
        close(nl_socket);
        exit(1);
    }
    
    printf("BTFS client connected to server %s\n", argv[1]);
    
    while (1) {
        memset(nlh, 0, NLMSG_SPACE(BUFFER_SIZE));
        
        iov.iov_base = (void *)nlh;
        iov.iov_len = NLMSG_SPACE(BUFFER_SIZE);
        msg.msg_name = (void *)&src_addr;
        msg.msg_namelen = sizeof(src_addr);
        msg.msg_iov = &iov;
        msg.msg_iovlen = 1;
        
        if (recvmsg(nl_socket, &msg, 0) >= 0) {
            handle_netlink_message(nlh);
        } else {
            break;
        }
    }
    
    free(nlh);
    close(bt_socket);
    close(nl_socket);
    return 0;
}
